/*
 * Copyright (C) 2021 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package app.cash.redwood.protocol.widget

import app.cash.redwood.Modifier
import app.cash.redwood.RedwoodCodegenApi
import app.cash.redwood.protocol.Change
import app.cash.redwood.protocol.ChangesSink
import app.cash.redwood.protocol.ChildrenChange
import app.cash.redwood.protocol.ChildrenChange.Add
import app.cash.redwood.protocol.ChildrenChange.Move
import app.cash.redwood.protocol.ChildrenChange.Remove
import app.cash.redwood.protocol.ChildrenTag
import app.cash.redwood.protocol.Create
import app.cash.redwood.protocol.EventSink
import app.cash.redwood.protocol.Id
import app.cash.redwood.protocol.ModifierChange
import app.cash.redwood.protocol.PropertyChange
import app.cash.redwood.protocol.WidgetTag
import app.cash.redwood.widget.ChangeListener
import app.cash.redwood.widget.Widget
import kotlin.native.ObjCName

/**
 * Bridges the serialized Redwood protocol back to widgets on the display side.
 *
 * This type will consume [Change]s and apply their [ChildrenChange] operations to the widget tree.
 * [PropertyChange]s and [ModifierChange]s are forwarded to their respective widgets.
 * Events from widgets are forwarded to [eventSink].
 */
@OptIn(RedwoodCodegenApi::class)
@ObjCName("ProtocolBridge", exact = true)
public class ProtocolBridge<W : Any>(
  container: Widget.Children<W>,
  factory: ProtocolFactory<W>,
  private val eventSink: EventSink,
  // TODO: this should come from the protocol, not from the caller.
  private val recycler: Recycler,
) : ChangesSink {
  public constructor(
    container: Widget.Children<W>,
    factory: ProtocolFactory<W>,
    eventSink: EventSink,
  ) : this(
    container = container,
    factory = factory,
    eventSink = eventSink,
    recycler = NullRecycler,
  )

  private val factory = requireNotNull(factory as? GeneratedProtocolFactory<W>) {
    "Factory ${factory::class} was not generated by Redwood or is out of date"
  }

  private val nodes = mutableMapOf<Id, ProtocolNode<W>>(
    Id.Root to RootProtocolNode(container),
  )
  private val changedWidgets = mutableSetOf<ChangeListener>()

  /** Nodes available for reuse. */
  private val pool = ArrayDeque<ProtocolNode<W>>()

  override fun sendChanges(changes: List<Change>) {
    @Suppress("NAME_SHADOWING")
    val changes = applyReuse(changes)

    for (i in changes.indices) {
      val change = changes[i]
      val id = change.id
      when (change) {
        is Create -> {
          val node = factory.createNode(change.tag) ?: continue
          node.widgetTag = change.tag
          node.reuseId = recycler.reuseId(change.tag)
          val old = nodes.put(change.id, node)
          require(old == null) {
            "Insert attempted to replace existing widget with ID ${change.id.value}"
          }
        }

        is ChildrenChange -> {
          val node = node(id)
          val children = node.children(change.tag) ?: continue
          when (change) {
            is Add -> {
              val child = node(change.childId)
              children.insert(change.index, child)
            }

            is Move -> {
              children.move(change.fromIndex, change.toIndex, change.count)
            }

            is Remove -> {
              children.remove(change.index, change.count)
              for (removedId in change.removedIds) {
                val removedNode = nodes.remove(removedId)
                if (removedNode?.reuseId != null) pool.addLast(removedNode)
              }
            }
          }

          val widget = node.widget
          if (widget is ChangeListener) {
            changedWidgets += widget
          }
        }

        is ModifierChange -> {
          val modifier = change.elements.fold<_, Modifier>(Modifier) { modifier, element ->
            modifier.then(factory.createModifier(element))
          }
          val node = node(id)
          node.updateModifier(modifier)

          val widget = node.widget
          if (widget is ChangeListener) {
            changedWidgets += widget
          }
        }

        is PropertyChange -> {
          val node = node(change.id)
          node.apply(change, eventSink)

          val widget = node.widget
          if (widget is ChangeListener) {
            changedWidgets += widget
          }
        }
      }
    }

    if (changedWidgets.isNotEmpty()) {
      for (widget in changedWidgets) {
        widget.onEndChanges()
      }
      changedWidgets.clear()
    }
  }

  private fun node(id: Id): ProtocolNode<W> {
    return checkNotNull(nodes[id]) { "Unknown widget ID ${id.value}" }
  }

  /**
   * Implements widget reuse (view recycling).
   *
   * When a widget is eligible from reuse:
   *
   *  * It is removed from [pool].
   *  * It is added to [nodes], alongside its descendant nodes.
   *
   * Returns the updated set of changes that omits any changes that were implemented with reuse.
   */
  private fun applyReuse(changes: List<Change>): List<Change> {
    val idToSubtree = mutableMapOf<Id, ReuseSubtree<W>>()

    for (change in changes) {
      if (change !is Create) continue
      val reuseId = recycler.reuseId(change.tag) ?: continue

      val candidateIndex = pool.indexOfFirst { it.reuseId == reuseId }
      if (candidateIndex == -1) continue

      idToSubtree[change.id] = ReuseSubtree(
        widgetId = change.id,
        childrenTag = ChildrenTag.Root,
        candidateReusedNode = pool.removeAt(candidateIndex),
      )
    }

    // Return early if there's no widgets to attempt to reuse for this set of changes.
    if (idToSubtree.isEmpty()) return changes

    // Collect subtree information in rounds, eventually terminating when we loop through all of the
    // changes without encountering an 'Add' change that we hadn't seen in a prior round.
    while (putSubtreesForChildrenOfSubtrees(idToSubtree, changes)) {
      // Keep going.
    }

    // We know the shape of each subtree. Process the Create and ChildrenChange objects.
    populateCreateIndexAndEligibleForReuse(idToSubtree, changes)

    // If the _shape_ of a reuse candidate matches the reused node, remove the corresponding
    // changes and use the reused node.
    val changesAndNulls: Array<Change?> = changes.toTypedArray()
    for (subtree in idToSubtree.values) {
      val reusedNode = subtree.candidateReusedNode ?: continue // Not a subtree root.
      if (subtree.shapeMatches(recycler, reusedNode)) {
        subtree.assignReusedNodeRecursive(nodes, changesAndNulls, reusedNode)
      }
    }

    // Build a new changes list that omits the events we no longer need.
    val result = mutableListOf<Change>()
    for (change in changesAndNulls) {
      if (change != null) result += change
    }

    return result
  }

  /**
   * Populate [idToSubtree] with the immediate children of the elements of [idToSubtree]. Call this
   * function in rounds until the entire tree is constructed.
   *
   * Returns true if new child nodes were found and added.
   */
  private fun putSubtreesForChildrenOfSubtrees(
    idToSubtree: MutableMap<Id, ReuseSubtree<W>>,
    changes: List<Change>,
  ): Boolean {
    var nodesAddedToMap = false
    for ((index, change) in changes.withIndex()) {
      if (change !is Add) continue
      val parentSubtree = idToSubtree[change.id] ?: continue // Parent isn't reused.
      if (idToSubtree[change.childId] != null) continue // Child already created.

      val childSubtree = ReuseSubtree<W>(
        widgetId = change.childId,
        childrenTag = change.tag,
        indexInParent = change.index,
        changeIndexForAdd = index,
      )
      idToSubtree[change.childId] = childSubtree
      parentSubtree.children += childSubtree
      nodesAddedToMap = true
    }

    return nodesAddedToMap
  }

  /** Returns true if any nodes were added to the map. */
  private fun populateCreateIndexAndEligibleForReuse(
    idToSubtree: MutableMap<Id, ReuseSubtree<W>>,
    changes: List<Change>,
  ) {
    for ((index, change) in changes.withIndex()) {
      when {
        // Track the Create for each node in the reuse subtrees.
        change is Create -> {
          val subtree = idToSubtree[change.id]
          if (subtree != null) {
            subtree.changeIndexForCreate = index
            subtree.widgetTag = change.tag
          }
        }

        // Any other children change disqualifies this node from reuse.
        change !is Add && change is ChildrenChange -> {
          val subtree = idToSubtree[change.id] ?: continue
          subtree.eligibleForReuse = false
        }
      }
    }
  }

  private class ReuseSubtree<W : Any>(
    val widgetId: Id,
    /** Which of its parent's slots this node is added to. */
    val childrenTag: ChildrenTag,
    /** Where this node goes in that slot. */
    val indexInParent: Int = -1,
    /**
     * The reused node that we'll attempt to match this node with. This is non-null if this node
     * has a reuseId, and null otherwise.
     */
    val candidateReusedNode: ProtocolNode<W>? = null,
    /** An index in the changes list to clear if the reuse is performed. */
    var changeIndexForAdd: Int = -1,
  ) {
    /** Another index in the changes list to clear if the reuse is performed. */
    var changeIndexForCreate: Int = -1

    val children = mutableListOf<ReuseSubtree<W>>()
    var eligibleForReuse = true
    var widgetTag: WidgetTag = UnknownWidgetTag

    /**
     * Returns true if this subtree and [other] have the same shape. The shapes match if:
     *
     *  * Both have the same widget tag
     *  * Both have the same number of children, in each slot
     *  * The paired up children have the same shape, recursively.
     *
     * Note that this condition isn't concerned with properties or modifiers.
     */
    fun shapeMatches(recycler: Recycler, other: ProtocolNode<*>): Boolean {
      if (!eligibleForReuse) return false // This node is ineligible.
      if (widgetTag == UnknownWidgetTag) return false // No 'Create' for this.
      if (other.widgetTag != widgetTag) return false // Widget types don't match.

      for (childrenTag in recycler.childrenTags(widgetTag)) {
        if (
          !shapeMatchesChildren(
            recycler = recycler,
            otherChildren = other.children(childrenTag)?.nodes ?: listOf(),
            childrenTag = childrenTag,
          )
        ) {
          return false
        }
      }

      return true
    }

    private fun shapeMatchesChildren(
      recycler: Recycler,
      otherChildren: List<ProtocolNode<*>>,
      childrenTag: ChildrenTag,
    ): Boolean {
      var childCount = 0

      for (child in children) {
        if (child.childrenTag != childrenTag) continue // From a different slot.
        if (child.indexInParent != childCount) return false // Out of order child?
        if (childCount >= otherChildren.size) return false // Other has fewer children.
        val otherChild = otherChildren[childCount++]
        if (!child.shapeMatches(recycler, otherChild)) return false // Subtree mismatch.
      }

      if (childCount != otherChildren.size) return false // Other has more children.
      return true
    }

    /**
     * When a reused node matches a newly-created node, this puts the reused node and its
     * descendants into the nodes map.
     */
    fun assignReusedNodeRecursive(
      nodes: MutableMap<Id, ProtocolNode<W>>,
      changesAndNulls: Array<Change?>,
      other: ProtocolNode<W>,
    ) {
      // Reuse the node.
      val old = nodes.put(widgetId, other)
      require(old == null) {
        "Insert attempted to replace existing widget with ID $widgetId"
      }

      // Remove the corresponding changes that we avoided by node reuse. We don't clear the 'Add'
      // that adds the subtree root to its new parent.
      changesAndNulls[changeIndexForCreate] = null
      if (changeIndexForAdd != -1) {
        changesAndNulls[changeIndexForAdd] = null
      }

      for (child in children) {
        child.assignReusedNodeRecursive(
          nodes = nodes,
          other = other.children(child.childrenTag)!!.nodes[child.indexInParent],
          changesAndNulls = changesAndNulls,
        )
      }
    }
  }

  public interface Recycler {
    /** TODO: Replace with something specified in guest code. */
    public fun reuseId(widgetTag: WidgetTag): ReuseId?

    /** TODO: Replace with something generated. */
    public fun childrenTags(widgetTag: WidgetTag): List<ChildrenTag>
  }

  public object NullRecycler : Recycler {
    override fun reuseId(widgetTag: WidgetTag): ReuseId? = null
    override fun childrenTags(widgetTag: WidgetTag): List<ChildrenTag> = listOf()
  }
}

@OptIn(RedwoodCodegenApi::class)
private class RootProtocolNode<W : Any>(
  children: Widget.Children<W>,
) : ProtocolNode<W>(), Widget<W> {
  private val children = ProtocolChildren(children)

  override fun apply(change: PropertyChange, eventSink: EventSink) {
    throw AssertionError("unexpected: $change")
  }

  override fun children(tag: ChildrenTag) = when (tag) {
    ChildrenTag.Root -> children
    else -> throw AssertionError("unexpected: $tag")
  }

  override val widget: Widget<W> get() = this

  override val value: W get() = throw AssertionError()

  override var modifier: Modifier
    get() = throw AssertionError()
    set(_) {
      throw AssertionError()
    }
}
